---
title: 'MCU'
description: 'Texas AM67 Cortex-R5, C7x (DSP)'
---

import SnippetBootflow from '/snippets/boards/o1/bootflow.mdx';
import SnippetClone from '/snippets/boards/o1/mcu/clone.mdx';
import SnippetInstallDeps from '/snippets/boards/o1/mcu/install-deps.mdx';
import SnippetTargets from '/snippets/boards/o1/mcu/targets.mdx';
import SnippetSysconfig from '/snippets/boards/o1/mcu/sysconfig.mdx';
import SnippetBuild from '/snippets/boards/o1/mcu/build.mdx';
import SnippetUpload from '/snippets/boards/o1/mcu/upload.mdx';
import SnippetHelloWorld from '/snippets/boards/o1/mcu/helloworld.mdx';
import SnippetFirmwares from '/snippets/boards/o1/mcu/firmwares.mdx';
import SnippetRemoteproc from '/snippets/boards/o1/mcu/remoteproc.mdx';
import SnippetResources from '/snippets/boards/o1/mcu/resource-table-tr.mdx';

<Tip>
Bölüm bitiminde aşağıdaki konularda bilgi ve deneyim kazanacaksınız.

* Texas AM67 MCU yazılımı derleyerek Gemstone Obsidyen üzerinde çalıştırmak
* Geliştirme kartına ilk güç verildiğinde hangi aşamalarla sistemin başladığını öğrenmek
* Geliştirme kartında bulunan Cortex-A (Linux) ve Cortex-R (MCU) farklı mimarilerde eşzamanlı olarak yazılım çalıştırılabildiğinin farkındalığını kazanmak
</Tip>

**T3-GEM-O1** geliştirme kartının birincil odak noktası Linux olmakla birlikte, üzerinde bulunan Texas AM67
mikroişlemcisinin barındırdığı R5 ve C7x çekirdeklerinin de gücünden faydalanılmaktadır. 
Örneğin Linux (Cortex-A) üzerinde görüntü işleme çeşitli işlemler yapıp bunları MCU (Cortex-R5) yazılımlarına
aktararak çeşitli servoların sürülmesi, sensörlerin okunması gibi senaryolara imkan sağlanabilmektedir.
Bu bölümde R5 çekirdekleri için nasıl yazılım derleneceği, debug yapılacağı vb. konular irdelenecektir.

## 1. Boot Diyagramı

Aşağıda belirtilen akış şeması Gemstone Obsidyen geliştirme kartı için olmakla birlikte bir çok ARM mimarili gömülü
Linux geliştirme kartlarında benzer bir yapı bulunmaktadır.

<SnippetBootflow/>

### 1.1. ROM Bootloader (RBL)

Üreticiler tarafından çoğu zaman kaynak kodları verilmeden sadece derlenmiş program olarak dağıtılan
RBL (Room Bootloader)'in temel amacı; karta ilk enerji verildiğinde donanım sağlık kontrolleri ve
ilklendirme vb. işlemleri yaparak, kaynak kodları değiştirilebilir olan SBL (Secondary Bootloader) isimli ikinci
Bootloader'a geçiş yapmaktır. SBL'in nereden okunarak başlatılacağı ise RBL tarafından Bootmode switchlerinden
tespit edilir.

### 1.2. Secondary Bootloader (SBL)

Secondary Boot Loader'un _T3-GEM-O1_ geliştirme kartlarındaki kullanım amacı
U-Boot isimli daha gelişmiş Bootloader'ı başlatmak ve Gemstone Imager isimli uygulama aracılığıyla imajların
[eMMC'ye yazılmasını](https://github.com/t3gemstone/texas-am67-sbl-gemboot/blob/main/main.c#L319) sağlamaktır.

Linux Kernel içeren gömülü kartlarda çoğunlukla U-Boot tercih edilmektedir. SBL gibi ön yükleyiciler daha temel seviyede
ilklendirme işlemleri yapabilirken, U-Boot çok daha gelişmiş özelliklere sahiptir. Örneğin U-Boot kendi Terminal/Konsol
arayüzüne ve SBL'de mümkün olmayan bir çok sürücüye sahip olduğu için daha gelişmiş özelleştirmelere imkan sağlar.

### 1.3. U-Boot

SBL sonrası geliştirme kartının kontrolünü devralan U-Boot, [Device Tree'de](/tr/faq#device-tree-nedir)
tanımlanmış olan konfigürasyonlara göre ilgili donanımların sürücülerini aktifleştirir ve ön tanımlı bir takım komutları
çalıştırarak Linux Kernel, Initrd gibi bileşenleri RAM'e yükleyerek kontrolü Linux Kernel'e devreder.

#### 1.3.1. U-Boot Konsol Alıştırmaları

<Tip>
Bu kısımda Gemstone geliştirme kartına TTL aracılığıyla bağlanılıp U-Boot konsol kullanımı gösterilmiştir.
Aşağıda bulunan dokümanlara hızlıca göz gezdirebilirsiniz.

- https://cm.e-ale.org/2018/u-boot/u-boot.pdf
- [https://software-dl.ti.com/jacinto7/esd...](https://software-dl.ti.com/jacinto7/esd/processor-sdk-linux-am67/09_02_00_04/exports/docs/linux/Foundational_Components/U-Boot/UG-General-Info.html)

</Tip>

<Frame caption="U-Boot Konsolu">
  <img className="rounded-lg" noZoom src="/images/tabby-uboot-console.png" />
</Frame>

### 1.4. Linux Kernel

[Device Tree'de](/tr/faq#device-tree-nedir) tanımlanan donanımların sürücülerini yükler. Ardından
varsa initrd'yi/initramfs'i başlatır ve rootfs'te bulunan `init` programını çalıştırır.

<Tip>
  U-Boot ve Linux kernelin [Device Tree](/tr/faq#device-tree-nedir) dosyaları birbirinden farklıdır. U-Boot'taki devicetreede
  genellikle sadece kernel ve initramfs'i çeşitli depolama aygıtlarından (MMC, SSD, SPI flash, ...)
  RAM'e yüklemeye yetecek kadar donanım aktif edilir. Asıl donanım aktif etme işlemlerini kernel yapar.
</Tip>

### 1.5. Initial RAM Disk (Initrd)

Rootfs başlatılmadan önce çeşitli kernel modüllerini yükleme, disk şifresini çözme, yazılım güncellemesi
yapma gibi ara işlemleri gerçekleştirmeyi sağlayan ve RAM üzerinde bulunan geçici dosya sistemidir.

<Tip>
  Rootfs diskte şifreli olarak tutuluyorsa, kernel direkt olarak `init` programını başlatamaz.
  Öncelikle disk şifresinin initramfs tarafından çözülmesi gerekir.
</Tip>

### 1.6. Root Filesystem (Rootfs)

Initrd, işlemlerini bitirdikten sonra rootfs olarak adlandırılan; sistem ve kullanıcı programlarını,
kütüphaneleri ve çeşitli konfigürasyon dosyalarını içeren dosya sistemini `/` dizinine bağlar.
Ardından kernel, rootfs'te `/init`, `/sbin/init` ya da benzeri bir dizinde bulunan `init` programını çalıştırır.
Bu program, bazı donanımların sürücülerini yükler (kernel modüllerini), sistem servislerini
(ağ bağlantısı, saat senkronizasyonu, paket güncelleme ve bluetooth gibi servisleri) ve masaüstü ortamını
başlatır (gnome, kde, xfce).

## 2. MCU Yazılım Geliştirme

MCU projelerini derleyebilmek için gerekli araçlar aşağıda listelenmiştir.

1. Texas Instruments Processor SDK RTOS J722S
2. Texas Instruments Sysconfig
3. Texas Instruments Code Generation Tools C7000
4. Texas Instruments Code Generation Tools ARM LLVM

<Tip>
Bu araçların Texas Instruments web sitesinden tek tek indirilip kurulumlarını gerçekleştirmek zahmetli olduğu için
[t3gemstone/examples](https://github.com/t3gemstone/examples) reposunda gerekli tüm araçları indirip
MCU projelerini derleyebilmek için altyapı oluşturulmuştur. Projeyi klonladığınızda otomatik kurulmaktadır.
</Tip>

### 2.1. Git clone işlemi ile örnek projeleri indir

<SnippetClone />

### 2.2. Derleme için gerekli araçları ve kütüphaneleri kur

<SnippetInstallDeps />

### 2.3. Taslak proje oluştur

[t3gemstone/examples](https://github.com/t3gemstone/examples) reposunda yer alan `mcu` projesinde iki R5F gerçek zamanlı
çekirdek ve iki C7x DSP çekirdeğinde çalışan örnek projeler bulunmaktadır. Bunlara benzer örnekler
`build/ti/ti-processor-sdk-rtos-j722s-evm-10_01_00_04/mcu_plus_sdk_j722s_10_01_00_22/examples` dizininde yer
almaktadır. Amacınıza uygun bir örnek proje bulup `mcu` proje dizinine kopyalamanız ve onun üzerinde geliştirme yapmanız
tavsiye edilir.

Her bir örnek projenin altında farklı çekirdekler için alt dizinler bulunmaktadır. 
Örneğin `hello_world` projesinde aşağıdaki dizinler mevcuttur.

<SnippetHelloWorld />

Yazılacak kodlar bu 4 çekirdekten hangisinde çalıştırılmak isteniyorsa
o dizinde geliştirme yapılmalı ve o dizindeki derlenmiş çıktılar kullanılmalıdır.

Derlenecek MCU projeleri `.env` dosyasında `MCU_TARGETS` değişkeni olarak tanımlanmıştır. Derlemek istediğiniz
projenin `makefile` dizininin mutlak veya göreli yolunu `MCU_TARGETS` değişkenine ekleyin. Aşağıda `hello_world`
projesinin `mcu-r5fss0-0_freertos` çekirdeği için örnek gösterilmiştir.

<SnippetTargets />

### 2.4. SysConfig ile çevre birimleri yapılandır

SysConfig, Texas Instruments (TI) tarafından geliştirilen bir yapılandırma aracı (configuration tool)’dur.
TI’nin mikrodenetleyici (MCU) ve işlemci tabanlı geliştirme ortamlarında kullanılır. Temel amacı donanım ve yazılım
ayarlarını görsel olarak yapılandırılmasını sağlar. Yani doğrudan karmaşık başlatma kodları yazmak yerine, bir
GUI üzerinden seçenekleri tıklayarak sistem yapılandırmasına imkan sağlar.

**Başlıca özellikleri:**

- Pin Muxing (Pin Yönlendirme): Hangi pinin hangi fonksiyonu üstleneceğini (UART, SPI, GPIO vb.) belirler.
- Peripheral Ayarları: UART, I2C, Timer, ADC gibi donanımların konfigürasyonunu yapar.
- Driver ve RTOS yapılandırması: TI-Drivers veya FreeRTOS bileşenlerini etkinleştirir.
- Otomatik Kod Üretimi: Yapılan ayarların C kaynak dosyalarını (.c, .h) otomatik oluşturur.
- Hata önleme: Uygun olmayan pin veya modül kombinasyonlarını algılayıp uyarır.

Projenin hangi çevre birimleri (GPIO, I2C, UART vb.) kullandığı ve bunların yapılandırması `.syscfg` dosyasında
tanımlanmıştır. Yeni çevre birimler eklemek veya mevcut olanların Pin Mux ayarlarını değiştirmek için SysConfig
GUI aracı kullanılır.

<Warning>
SysConfig GUI aracını kullanmadan önce kaynakları doğru bir şekilde paylaştırmak ve beklenmedik hatalarla karşılaşmamak için 
[Kaynakların çekirdekler arasında paylaştırılması](/tr/boards/o1/peripherals/mcu#3-kaynakların-çekirdekler-arasında-paylaştırılması)
bölümünü okuyunuz.
</Warning>

Bir MCU projesinde SysConfig'i başlatmak için:

- `SYSCONFIG_TARGET` değişkenini istenen proje olarak değiştirin.
    - Bu değişkeni `.env` dosyası içinde düzenleyebilir veya
    - `task` programına ortam değişkeni olarak iletebilirsiniz.

<SnippetSysconfig />

Değişikliklerinizi `Ctrl + S` kısayol tuşuyla kaydettikten sonra SysConfig arayüzünü kapatabilirsiniz.

<Warning>
Linux tarafından R5F ve C7x çekirdeklerine uzaktan yazılım yüklenebilmesi için remoteproc altyapısı kullanılmaktadır.
Bir projenin derlenmiş `.out` dosyasının remoteproc ile yüklenebilmesi için SysConfig arayüzünden bazı ayarların
yapılmış olması gerekmektedir. Yeni bir proje kopyalandıktan sonra aşağıdaki adımlar izlenmelidir.

1. `TI DRIVERS` altında yer alan `IPC` sekmesi açılır.
2. `ADD` butonuna tıklanır.
3. `Linux A53 IPC RP Message` ayarının aktif olduğuna emin olunur.
4. `Ctrl + S` kısayol tuşuyla `.syscfg` dosyası kaydedilip çıkılır.
</Warning>

### 2.5. Projeyi derle

<SnippetBuild />

### 2.6. Derlenmiş projeyi geliştirme kartına yükle

<SnippetUpload />

### 2.7. Derlenmiş projeyi çalıştır

Remoteproc ile çekirdeklere yüklenecek `.out` dosyaları `/lib/firmware` dizini altına önceden tanımlı isimlerde
kopyalanmalıdır. Her bir çekirdek için firmware ismi aşağıdaki tabloda verilmiştir.

<SnippetFirmwares />

Firmware isimlerine ve hangi çekirdeğin hangi remoteproc cihazına karşılık geldiğine
`head /sys/class/remoteproc/remoteproc*/firmware` komutu ile erişilebilir. Her boot sonrasında çekirdekler
farklı remoteproc cihazlarına karşılık gelebildiği için kontrol edilmesi gerekmektedir.

<SnippetRemoteProc />

<Warning>
Yukarıdaki prosedür, uzak çekirdeklerin sorunsuz bir şekilde kapatılmasını ve yeniden başlatılmasını sağlar. Bazı
durumlarda sorunsuz kapatma işlemi başarısız olabilir. Bu durumda şu adımları öneririz:

1. Yeni firmware dosyalarını `/lib/firmware` dizinine yerleştirin.
2. Kartı yeniden başlatın.

Sistem başlangıcında, remoteproc mekanizması firmware'leri ilgili çekirdeklere otomatik olarak yükleyecektir.

**Not:** Bu yaklaşım özellikle şu durumlarda kullanışlıdır:

- Çekirdek çökmeleri yaşandığında
- IPC iletişimi kesildiğinde
- Dinamik yükleme sırasında beklenmeyen davranışlar gözlemlendiğinde
</Warning>

### 2.8. Derlenmiş projenin U-Boot aşamasında çalıştırılması

[Boot Diyagramı](/tr/boards/o1/peripherals/mcu#1-boot-diyagramı) bölümündeki şekilde görüldüğü gibi bir önceki
bölümde anlatılan çalıştırma yöntemi kullanıldığında MCU uygulamasının çalışabilmesi için
Linux'un başlama sürecini tamamlayıp çekirdeklerin yazılımlarını yükleyip başlatması gerekir.
Bu süreç bazı uygulamalarda istenmeyen gecikmelere neden olabilir. Bu gecikme uzak çekirdekler bootloader (U-Boot)
aşamasında başlatılarak önlenebilir.

1. Öncelikle derlenen uygulama `/boot/mcu-fw/` dizinine kopyalanır.
2. `/boot/uEnv.txt` dosyasında derlenen uygulama hangi çekirdeğe aitse aşağıdaki tablo kullanılarak gerekli
   parametre tanımlanır.

| Çekirdek       | Değişken Adı           |
|----------------|------------------------|
| main-r5fss0-0  | main_r5f_firmware_name |
| mcu-r5fss0-0   | mcu_r5f_firmware_name  |
| wkup-r5fss0-0  | wkup_r5f_firmware_name |
| c7xss0-0       | c7x0_dsp_firmware_name |
| c7xss1-0       | c7x1_dsp_firmware_name |

Örneğin `blink_main_r5` isimli bir uygulama U-Boot aşamasında main-r5fss0-0 çekirdeğinde çalıştırılmak istendiğinde
öncelikle uygulama aşağıda görüldüğü gibi `/boot/mcu-fw` dizinine kopyalanır.

```sh
gemstone@t3-gem-o1:~$ ls /boot/mcu-fw/
total 102K
drwxr-xr-x 2 root root  512 Jan  1  2000 ./
drwxr-xr-x 4 root root 1.0K Jan  1  1970 ../
-rwxr-xr-x 1 root root 101K Jan  1  2000 blink_main_r5*
```

Ardından `/boot/uEnv.txt` dosyasına aşağıdaki satır eklenir.

```txt
main_r5f_firmware_name=blink_main_r5
```

Artık `blink_main_r5` uygulaması Linux'un başlamasını beklemek yerine doğrudan bootloader aşamasında başlatılacaktır.

## 3. Kaynakların Çekirdekler Arasında Paylaştırılması

AM67'nin çok çekirdekli bir işlemci olması dolayısıyla, sahip olduğu kaynakların bu çekirdekler arasında
paylaştırılması gerekmektedir. Örneğin `main_uart1` uart çevre birimi hem Linux (A53 çekirdekler) tarafından hem de
main-r5fss0-0 çekirdeği tarafından aynı anda kullanılamaz. Eğer bu UART çevre birimi MCU tarafından kullanılacaksa
Linux tarafından bu birimin kullanılmadığının belirtilmesi gerekmektedir.

### 3.1. Varsayılan Kaynak Dağılımı Tablosu

Aşağıda verilen tabloda HAT'a çıkan pinlerin SOC'de hangi pinlere denk geldiği, hangi çevre birim olarak
kullanılabilecekleri (Pinmux), Linux tarafından varsayılan olarak kullanılıp kullanılmadığı, kullanılıyorsa
hangi amaçla kullanıldığı ve bunun nasıl devre dışı bırakılabileceği gibi bilgiler bulunabilir. 

<SnippetResources />

Devre dışı bırakılacak pinin tabloda `Devre Dışı Bırakmak için` isimli sütununa bakılır. Bu sütunda
k3-am67a-t3-gem-o1-xxxxxx.dtbo şeklinde listelenen device-tree overlay ismi verilen dosyalar Linux'a belirtilen
çevre birimi nasıl kullanması gerektiğini bildiren ayar dosyalarıdır.

İlgili ayarları devre dışı bırakmak için `/boot/uEnv.txt` dosyasını açıp `overlays` ismi verilen değişkenden bu
dosyanın silinmesi yeterlidir. Bazı pinlerin `Devre Dışı Bırakmak için` sütünunda overlaylerin
haricinde `Device-tree ile devre dışı bırakılmalı. (mcu_spi0)` benzeri yönergeler mevcuttur. Bunları devre dışı
bırakmak için;

- https://github.com/t3gemstone/devicetrees reposu klonlanır.
- `src/arm64/ti/k3-am67a-t3-gem-o1.dts` dosyası açılır ve aşağıdaki kod parçası gerekli değişiklikler yapılarak eklenir.
  ```c
  &mcu_spi0 {
    status = "disabled";
  };
  ```
- Repo dizininde `make` komutu çalıştırılarak device-tree derlenir.
- Eski device-tree `$ sudo mv /boot/k3-am67a-t3-gem-o1.dtb /boot/k3-am67a-t3-gem-o1.dtb.bak` komutu ile yedeklenir.
- Derleme sonucu oluşan `src/arm64/ti/k3-am67a-t3-gem-o1.dtb` dosyası `/boot/` altına kopyalanır.
- Kart yeniden başlatılır ve çalışıp çalışmadığı test edilir.

<Note>
Yukarıdaki işlemler sonucu istenmeyen bir durum oluşursa
`$ sudo cp /boot/k3-am67a-t3-gem-o1.dtb.bak /boot/k3-am67a-t3-gem-o1.dtb` komutu ile yedeklenen device-tree geri yüklenebilir.
</Note>

Yukarıdaki işlemler sonucunda artık `mcu_spi0` mcu çekirdeklerden kullanılabilir durumda olacaktır. Ancak tabloda
bulunan `Linux'ta Kullanım Amacı` bölümünde `- BMP390 basınç ve ICM20948 imu spi` için kullanıldığı belirtilmiştir.
Dolayısıyla bu çevresel birimlere Linux'ta erişim kapatılmış olacak ve MCU tarafından sürülmesi gerekecektir. 

### 3.2. Örnek Senaryo: PWM ile MCU'dan Servo Motorun Sürülmesi

Elimizde bulunan SG90 model bir servo motoru MCU çekirdekten sürmemiz gerektiği bir senaryoda öncelikle HAT
pinleri üzerinde bulunan bir PWM pinini seçmeliyiz. Örneğin `GPIO-12` pini seçilmiş olsun. Tabloya
baktığımızda bu pinin Linux tarafından kullanımda olduğunu görebiliriz. Bu pini Linux'ta
devre dışı bırakmak için `Devre Dışı Bırakmak için` sütununa baktığımızda yalnızca bir overlay dosyası bulunduğu
görülür. Kapatmak için `/boot/uEnv.txt` dosyasını açıp `overlays` değişkenini kontrol ediyoruz.

```txt
overlays=k3-am67a-t3-gem-o1-i2c1-400000.dtbo k3-am67a-t3-gem-o1-pwm-ecap0-gpio12.dtbo k3-am67a-t3-gem-o1-pwm-epwm1-gpio13.dtbo k3-am67a-t3-gem-o1-spidev0-2cs.dtbo
```

Burada tabloda belirtilen `k3-am67a-t3-gem-o1-pwm-ecap0-gpio12.dtbo` dosyasının adını görebiliriz. Bunu siliyoruz ve
overlays değişkeni aşağıdaki şekle geliyor.

```txt
overlays=k3-am67a-t3-gem-o1-i2c1-400000.dtbo k3-am67a-t3-gem-o1-pwm-epwm1-gpio13.dtbo k3-am67a-t3-gem-o1-spidev0-2cs.dtbo
```

Kart yeniden başlatıldığında bu pin MCU tarafından kontrol edilebilir.

## 4. Son

<Tip>
Boot süreci hakkında bir kaç makale örneği aşağıda verilmiştir.

- [BeagleBone Black Linux Boot Süreci](https://serbayozkan.medium.com/embedded-linux-boot-s%C3%BCreci-beagle-bone-black-ba9d378bd3bd)
- [Booting Embedded Linux On BeagleBone](https://medium.com/@kshitijvaze/booting-embedded-linux-on-beaglebone-black-a-look-beyond-the-code-20854568fb66)
</Tip>
